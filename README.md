Известно, что число консенсуса для операций `read` и `write` равно 1. Значит, вместе с `multiread` оно будет *хотя бы* один.

Докажем, что на самом деле оно в точности 1. Для этого будем действовать от противного и предположим, что есть реализация метода `Decide(v)`, использующая только эти три операции и разрешающая консенсус для двух потоков.

На самом деле дальнейшие рассуждения будут мало отличаться от лекционных. Введём упрощение: передаваемое в `Decide` значение *v* равно 0 или 1. Даже в таких условиях консенсус невозможно реализовать. Введём ориентированный граф возможных исполнений программы. Вершины в нём будут обозначать состояние исполнения (общая область памяти + 2 набора локальных регистров (для каждого потока) + 2 указателя на текущие инструкции (для каждого потока)). Ребро будет означать исполнение следующей операции в каком-то одном потоке. Именно так "по рёбрам" мы в процессе исполнения переходим от одного состояния к другому.

<img src='https://pp.userapi.com/c850736/v850736774/122371/vfA9sOngHB0.jpg'>

На рисунке показан пример графа исполнения в случае, когда функция `Decide` состоит из одной команды (и не выполняет то, что мы от неё хотим :) ). Различными цветами обозначены потоки. Около вершин написаны локальный регистры (общие переменные не нарисованы).

Таким образом, из одной вершины может вести максимум два ребра, потому что у нас два потока. Или даже одно, если какой-то поток уже завершился. Планировщик может выбрать произвольный маршрут исполнения. В графе нет циклов, потому что тогда было бы возможно бесконечное исполнение, а это нарушение гарантии **wait-free**.

В графе есть листы, которые обозначают конец исполнения. В листах должно быть известно значение, возвращаемое всем потокам. Вершины с таким свойством назовём *унивалентными* (или *0-, 1-валентными*, в зависимости от известного значения). Например, вершина, все рёбра из которой ведут в 0-валентные листы, сама 0-валентная. В начальной же вершине (точке входа) это значение неизвестно. Такие вершины назовём *бивалентными*.

В графе *должна* существовать бивалентная вершина, из которой ведут два ребра в 0-валентную и 1-валентную вершины. Какие это рёбра? Пусть одно из них совершает какую-либо операцию чтения (`read` или `multiread` &mdash; не важно). БОО это ребро ведёт в 0-валентную вершину.

<img src='https://pp.userapi.com/c850736/v850736774/122390/6FS8DzRYOEM.jpg'>

Заставим планироващик пройти по правому ребру, а далее как угодно. В итоге, поскольку красное ребро вело в 1-валентную вершины, результат работы алгоритма &mdash; 1.

Теперь посмотрим, что будет, если пройти по левому ребру. Заметим, что во время операции чтения меняются только локальные регистры потока: красный поток изменений не заметит. Поэтому после перехода по левому ребру можно проделать весь путь из предыдущего пункта:

<img src='https://pp.userapi.com/c850736/v850736774/1223a1/_gUsBGnoJSs.jpg'>

Получается, после прохода через 0-валентную вершины, алгоритм вернул единицу. Противоречие. Значит, оба ребра делают операцию `write`.

Заметим, что если оба ребра делают `write` по одному и тому же адресу, то можно проделать прежний трюк. Пусть рёбра делают `write` по разным адресам. Тогда рассмотрим два исполнения, как на рисунке:

<img src='https://pp.userapi.com/c850736/v850736697/12084a/mdqpFvSj0dA.jpg'>

Они оба приводят в одно и то же состояние, но какова валентность соответствующей вершины, непонятно.

Полученнное полное противоречие доказывает невозможность консенсуса для 2-х потоков. А поскольку для одного потока консенсус возможен, то ответ &mdash; 1.
